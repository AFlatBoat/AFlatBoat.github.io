(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{412:function(t,a,s){t.exports=s.p+"assets/img/design-patterns.36aee8e0.png"},437:function(t,a,s){"use strict";s.r(a);var r=s(2),e=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[t._v("#")]),t._v(" 设计模式")]),t._v(" "),a("h2",{attrs:{id:"六大原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六大原则"}},[t._v("#")]),t._v(" 六大原则")]),t._v(" "),a("h3",{attrs:{id:"单一职责原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则"}},[t._v("#")]),t._v(" 单一职责原则")]),t._v(" "),a("p",[t._v("一个类只负责一个功能领域中的相应职责")]),t._v(" "),a("h3",{attrs:{id:"开闭原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开闭原则"}},[t._v("#")]),t._v(" 开闭原则")]),t._v(" "),a("p",[t._v("一个软件实体应当对扩展开放，对修改关闭")]),t._v(" "),a("h3",{attrs:{id:"里氏替换原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#里氏替换原则"}},[t._v("#")]),t._v(" 里氏替换原则")]),t._v(" "),a("p",[t._v("所有引用基类（父类）的地方必须能透明地使用其子类的对象")]),t._v(" "),a("h3",{attrs:{id:"依赖倒置原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒置原则"}},[t._v("#")]),t._v(" 依赖倒置原则")]),t._v(" "),a("p",[t._v("需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中")]),t._v(" "),a("h3",{attrs:{id:"接口隔离原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离原则"}},[t._v("#")]),t._v(" 接口隔离原则")]),t._v(" "),a("p",[t._v("当一个接口太大时，我们需要将它分割成一些更细小的接口")]),t._v(" "),a("h3",{attrs:{id:"迪米特法则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#迪米特法则"}},[t._v("#")]),t._v(" 迪米特法则")]),t._v(" "),a("p",[t._v("一个模块发生修改时，应该尽量少地影响其他模块")]),t._v(" "),a("p",[a("img",{attrs:{src:s(412),alt:"设计模式"}})])])}),[],!1,null,null,null);a.default=e.exports}}]);